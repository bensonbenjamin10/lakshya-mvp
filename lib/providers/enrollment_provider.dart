import 'package:flutter/foundation.dart';
import 'package:lakshya_mvp/core/repositories/enrollment_repository.dart';
import 'package:lakshya_mvp/models/enrollment.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Enrollment provider for managing enrollment state
/// 
/// Follows Provider pattern and SOLID principles
class EnrollmentProvider with ChangeNotifier {
  final EnrollmentRepository _repository;
  final SupabaseClient _client;

  List<Enrollment> _enrollments = [];
  Enrollment? _selectedEnrollment;
  bool _isLoading = false;
  String? _error;

  EnrollmentProvider(this._repository, this._client) {
    _loadEnrollments();
    _setupRealtimeSubscription();
  }

  List<Enrollment> get enrollments => _enrollments;
  Enrollment? get selectedEnrollment => _selectedEnrollment;
  bool get isLoading => _isLoading;
  String? get error => _error;

  /// Get enrollments for current user
  Future<void> _loadEnrollments() async {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) {
      _enrollments = [];
      notifyListeners();
      return;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      _enrollments = await _repository.getByStudentId(userId);
      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      debugPrint('Error loading enrollments: $e');
      notifyListeners();
    }
  }

  /// Check if current user is enrolled in a course
  Future<bool> isEnrolledInCourse(String courseId) async {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) return false;

    try {
      return await _repository.isEnrolled(
        studentId: userId,
        courseId: courseId,
      );
    } catch (e) {
      debugPrint('Error checking enrollment: $e');
      return false;
    }
  }

  /// Get enrollment for a specific course
  Future<Enrollment?> getEnrollmentForCourse(String courseId) async {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) return null;

    try {
      return await _repository.getByStudentAndCourse(
        studentId: userId,
        courseId: courseId,
      );
    } catch (e) {
      debugPrint('Error fetching enrollment: $e');
      return null;
    }
  }

  /// Create a new enrollment
  Future<Enrollment?> enrollInCourse({
    required String courseId,
    bool paymentRequired = true,
  }) async {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) {
      _error = 'User not authenticated';
      notifyListeners();
      return null;
    }

    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final enrollment = Enrollment(
        id: '', // Will be generated by database
        studentId: userId,
        courseId: courseId,
        status: EnrollmentStatus.pending,
        paymentStatus: paymentRequired ? PaymentStatus.pending : PaymentStatus.notRequired,
        paymentRequired: paymentRequired,
        enrolledAt: DateTime.now(),
      );

      final created = await _repository.create(enrollment);
      await _loadEnrollments(); // Refresh list
      return created;
    } catch (e) {
      _error = e.toString();
      _isLoading = false;
      debugPrint('Error enrolling in course: $e');
      notifyListeners();
      return null;
    }
  }

  /// Select an enrollment
  void selectEnrollment(Enrollment enrollment) {
    _selectedEnrollment = enrollment;
    notifyListeners();
  }

  /// Clear selection
  void clearSelection() {
    _selectedEnrollment = null;
    notifyListeners();
  }

  /// Refresh enrollments
  Future<void> refresh() async {
    await _loadEnrollments();
  }

  /// Setup realtime subscription for enrollment updates
  void _setupRealtimeSubscription() {
    final userId = _client.auth.currentUser?.id;
    if (userId == null) return;

    _client
        .from('enrollments')
        .stream(primaryKey: ['id'])
        .eq('student_id', userId)
        .listen((data) {
      // Reload enrollments when changes occur
      _loadEnrollments();
    });
  }

  @override
  void dispose() {
    // Cleanup handled by Supabase client
    super.dispose();
  }
}

